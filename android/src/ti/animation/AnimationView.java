/*
  This file was auto-generated by the Titanium Module SDK helper for Android
  Appcelerator Titanium Mobile
  Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
  Licensed under the terms of the Apache Public License
  Please see the LICENSE included with this distribution for details.
 */
package ti.animation;

import static ti.animation.TiAnimationModule.ANIMATION_LOTTIE;
import static ti.animation.TiAnimationModule.ANIMATION_RIVE;

import android.animation.Animator;
import android.animation.ValueAnimator;
import android.annotation.SuppressLint;
import android.content.res.Resources;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.widget.ImageView.ScaleType;

import androidx.startup.AppInitializer;

import com.airbnb.lottie.LottieAnimationView;
import com.airbnb.lottie.LottieComposition;
import com.airbnb.lottie.LottieCompositionFactory;
import com.airbnb.lottie.LottieDrawable;
import com.airbnb.lottie.LottieOnCompositionLoadedListener;
import com.airbnb.lottie.TextDelegate;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiMessenger;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.io.TiBaseFile;
import org.appcelerator.titanium.io.TiFileFactory;
import org.appcelerator.titanium.proxy.TiViewProxy;
import org.appcelerator.titanium.util.TiConvert;
import org.appcelerator.titanium.view.TiUIView;
import org.json.JSONObject;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import app.rive.runtime.kotlin.RiveAnimationView;
import app.rive.runtime.kotlin.RiveInitializer;
import app.rive.runtime.kotlin.core.Alignment;
import app.rive.runtime.kotlin.core.Direction;
import app.rive.runtime.kotlin.core.Fit;
import app.rive.runtime.kotlin.core.Loop;

public class AnimationView extends TiUIView implements LottieOnCompositionLoadedListener {

    private static final String LCAT = "AnimationViewProxy";
    private final TiViewProxy proxy;
    public int animationType = ANIMATION_LOTTIE;
    ByteArrayOutputStream byteBuffer;
    private LottieAnimationView lottieView;
    private RiveAnimationView riveView;
    private TextDelegate delegate;
    private KrollFunction callbackReady = null;
    private float initialDuration = 0;
    private ValueAnimator va = null;

    @SuppressLint("ClickableViewAccessibility")
    AnimationView(TiViewProxy proxy) {
        super(proxy);

        this.proxy = proxy;
        String packageName = proxy.getActivity().getPackageName();
        Resources resources = proxy.getActivity().getResources();
        View viewWrapper;

        int resId_viewHolder;
        int resId_aniView;

        if (TiConvert.toInt(proxy.getProperty("animationType")) == ANIMATION_RIVE) {
            AppInitializer.getInstance(TiApplication.getAppCurrentActivity())
                    .initializeComponent(RiveInitializer.class);
            resId_viewHolder = resources.getIdentifier("layout_rive", "layout", packageName);
        } else {
            resId_viewHolder = resources.getIdentifier("layout_lottie", "layout", packageName);
        }
        resId_aniView = resources.getIdentifier("animation_view", "id", packageName);

        LayoutInflater inflater = LayoutInflater.from(proxy.getActivity());
        viewWrapper = inflater.inflate(resId_viewHolder, null);

        if (TiConvert.toInt(proxy.getProperty("animationType")) == ANIMATION_RIVE) {
            riveView = viewWrapper.findViewById(resId_aniView);
            animationType = ANIMATION_RIVE;
            MotionEvent mEvent = null;
            riveView.setOnTouchListener((view, motionEvent) -> {
                if (motionEvent.getAction() == MotionEvent.ACTION_UP) {
                    fireEvent("click", new KrollDict());
                }
                return false;
            });
        } else {
            lottieView = viewWrapper.findViewById(resId_aniView);
            delegate = new TextDelegate(lottieView);
            setScaleMode(TiConvert.toString(proxy.getProperty("scaleMode")));
            lottieView.addAnimatorUpdateListener(new AnimatorUpdateListener());
            lottieView.addAnimatorListener(new AnimatorListener());
            lottieView.addLottieOnCompositionLoadedListener(this);

            if (TiConvert.toBoolean(proxy.getProperty("disableHardwareAcceleration"))) {
                lottieView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
            } else {
                lottieView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
            }
            lottieView.enableMergePathsForKitKatAndAbove(TiConvert.toBoolean(proxy.getProperty("mergePath")));
        }
        setNativeView(viewWrapper);
    }

    @Override
    public void processProperties(KrollDict d) {
        super.processProperties(d);

        if (d.containsKey("scaleMode")) {
            setScaleMode(d.getString("scaleMode"));
        }
        if (d.containsKey("disableHardwareAcceleration")) {
            if (d.getBoolean("disableHardwareAcceleration")) {
                if (lottieView != null) lottieView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
            } else {
                if (lottieView != null) lottieView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
            }
        }
        if (d.containsKey("loop")) {
            if (animationType == ANIMATION_LOTTIE) {
                if (lottieView != null)
                    lottieView.setRepeatCount(d.getBoolean("loop") ? LottieDrawable.INFINITE : 0);
            }
        }
        if (d.containsKey("ready")) {
            callbackReady = (KrollFunction) d.get("ready");
        }
        if (d.containsKey("mergePath")) {
            if (lottieView != null)
                lottieView.enableMergePathsForKitKatAndAbove(d.getBoolean("mergePath"));
        }
        if (d.containsKey("progress")) {
            setProgress(Float.parseFloat(d.getString("progress")));
        }
        if (d.containsKey("speed")) {
            Object speed = d.get("speed");
            if (speed != null) {
                proxy.setProperty("duration", (initialDuration / TiConvert.toFloat(speed)));
            }
        }
        if (d.containsKey("autoStart")) {
            proxy.setProperty("autoStart", d.getBoolean("autoStart"));
        }
        if (d.containsKey("start")) {
            if (d.getBoolean("start")) {
                startAnimation(TiConvert.toInt(proxy.getProperty("startFrame")),
                        TiConvert.toInt(proxy.getProperty("endFrame")));
            }
        }

        if (d.containsKey("file") && !d.getString("file").equals("")) {
            if (TiApplication.isUIThread()) {
                loadFile(d.getString("file"));
            } else {
                TiMessenger.sendBlockingMainMessage(
                        proxy.getMainHandler().obtainMessage(AnimationViewProxy.MSG_LOAD_FILE, d.getString("file")));
            }
        } else if (d.containsKey("json")) {
            loadJson(d.getString("json"));
        }
    }

    @Override
    public void propertyChanged(String key, Object oldValue, Object newValue, KrollProxy proxy) {
        KrollDict d = new KrollDict();
        d.put(key, newValue);
        processProperties(d);
    }

    private void setScaleMode(String smode) {
        // Set scale mode on view
        //
        if (animationType == ANIMATION_RIVE) {
            return;
        }

        if (lottieView == null) return;

        switch (smode) {
            case "center":
                lottieView.setScaleType(ScaleType.CENTER);
                break;
            case "centerCrop":
                lottieView.setScaleType(ScaleType.CENTER_CROP);
                break;
            case "stretch":
                lottieView.setScaleType(ScaleType.FIT_XY);
                break;
            case "centerInside":
            default:
                lottieView.setScaleType(ScaleType.CENTER_INSIDE);
                break;
        }
    }

    private void parseJson(String json) {
        try {
            JSONObject jsonObject = new JSONObject(json);
            proxy.setProperty("width", jsonObject.optInt("w", 0));
            proxy.setProperty("height", jsonObject.optInt("h", 0));
        } catch (Exception e) {
            Log.e(LCAT, "Couldn't read width/height");
        }
    }

    private void loadJson(String jsonString) {
        try {
            parseJson(jsonString);
            LottieCompositionFactory.fromJsonStringSync(jsonString, null);
        } catch (Exception e) {
            Log.e(LCAT, "Could not parse JSON string");
        }
    }

    @Override
    public void onCompositionLoaded(LottieComposition composition) {
        lottieView.setComposition(composition);
        lottieView.setImageAssetsFolder("Resources/" + TiConvert.toString(proxy.getProperty("assetFolder")));
        lottieView.setTextDelegate(delegate);

        initialDuration = lottieView.getDuration();
        if (TiConvert.toFloat(proxy.getProperty("speed")) == 1.0f) {
            proxy.setProperty("duration", initialDuration);
        } else {
            proxy.setProperty("duration", (initialDuration / TiConvert.toFloat(proxy.getProperty("speed"))));
        }
        if (TiConvert.toBoolean(proxy.getProperty("loop"))) {
            lottieView.setRepeatCount(LottieDrawable.INFINITE);
        }
        if (TiConvert.toBoolean(proxy.getProperty("autoStart"))) {
            startAnimation(TiConvert.toInt(proxy.getProperty("startFrame")),
                    TiConvert.toInt(proxy.getProperty("endFrame")));
        }
        if (callbackReady != null) {
            callbackReady.call(proxy.getKrollObject(), new KrollDict());
        }
        ((AnimationViewProxy) proxy).readyEvent(new KrollDict());
    }

    void loadFile(String f) {
        String url = proxy.resolveUrl(null, f);
        TiBaseFile file = TiFileFactory.createTitaniumFile(new String[]{url}, false);

        if (file.exists()) {
            try {
                InputStream stream = file.getInputStream();

                if (animationType == ANIMATION_RIVE) {
                    byteBuffer = new ByteArrayOutputStream();
                    int bufferSize = 1024;
                    byte[] buffer = new byte[bufferSize];
                    int len = 0;
                    while ((len = stream.read(buffer)) != -1) {
                        byteBuffer.write(buffer, 0, len);
                    }

                    String artboard = null;
                    String ani = null;
                    String state = null;
                    Loop loop = Loop.ONESHOT;

                    if (proxy.hasPropertyAndNotNull("artboardName")) {
                        artboard = TiConvert.toString(proxy.getProperty("artboardName"));
                    }
                    if (proxy.hasPropertyAndNotNull("animationName")) {
                        ani = TiConvert.toString(proxy.getProperty("animationName"));
                    }
                    if (proxy.hasPropertyAndNotNull("stateName")) {
                        state = TiConvert.toString(proxy.getProperty("stateName"));
                    }
                    if (proxy.hasPropertyAndNotNull("loop")) {
                        if (TiConvert.toInt(proxy.getProperty("loop")) == 0) {
                            loop = Loop.ONESHOT;
                        } else if (TiConvert.toInt(proxy.getProperty("loop")) == 1) {
                            loop = Loop.LOOP;
                        }
                    }
                    riveView.setRiveBytes(byteBuffer.toByteArray(),
                            artboard,
                            ani,
                            state,
                            true,
                            Fit.CONTAIN,
                            Alignment.CENTER,
                            loop);
                } else {
                    int size = stream.available();
                    byte[] buffer = new byte[size];
                    stream.read(buffer);
                    String json = new String(buffer, StandardCharsets.UTF_8);
                    parseJson(json);
                    lottieView.setAnimation(url.replaceAll("file:///android_asset/", ""));
                }
            } catch (Exception e) {
                Log.e(LCAT, "Error opening file " + file.name() + "\n" + e.getMessage());
            }
        } else {
            Log.e(LCAT, "File " + file.name() + " not found!");
        }
    }

    void startAnimation(Object data) {
        if (animationType == ANIMATION_RIVE) {
            HashMap kd = (HashMap) data;
            String aniName = TiConvert.toString(kd.get("animationName"));
            Boolean loop = TiConvert.toBoolean(kd.get("loop"));
            Loop l = Loop.ONESHOT;
            if (loop) {
                l = Loop.LOOP;
            }
            riveView.play(aniName, l, Direction.AUTO, false, false);
        }
    }

    void startAnimation(int startFrame, int endFrame) {
        if (animationType == ANIMATION_RIVE) return;
        if (lottieView.isAnimating()) {
            lottieView.cancelAnimation();
        }
        lottieView.setProgress(0f);
        proxy.setProperty("paused", false);

        if (startFrame == -1 && TiConvert.toInt(proxy.getProperty("startFrame"), -1) != -1) {
            startFrame = TiConvert.toInt(proxy.getProperty("startFrame"), -1);
        }

        if (endFrame == -1 && TiConvert.toInt(proxy.getProperty("endFrame"), -1) != -1) {
            endFrame = TiConvert.toInt(proxy.getProperty("endFrame"), -1);
        }

        if (TiConvert.toFloat(proxy.getProperty("speed")) == 1.0f) {
            if (startFrame != -1) {
                lottieView.setMinFrame(startFrame);
            }
            if (endFrame != -1) {
                lottieView.setMaxFrame(endFrame);
            }
            lottieView.playAnimation();
            va = null;
        } else {
            va = ValueAnimator.ofFloat(0f, 1f);
            va.setDuration((long) TiConvert.toFloat(proxy.getProperty("duration")));

            if (TiConvert.toBoolean(proxy.getProperty("loop"))) {
                va.setRepeatCount(-1);
            }
            va.addUpdateListener(animation -> {
                lottieView.setProgress((Float) animation.getAnimatedValue());
                KrollDict event = new KrollDict();
                event.put("frame", lottieView.getFrame());
                event.put("status", AnimationViewProxy.ANIMATION_RUNNING);
                ((AnimationViewProxy) proxy).updateEvent(event);
            });

            va.addListener(new Animator.AnimatorListener() {
                @Override
                public void onAnimationStart(Animator animation) {
                    KrollDict event = new KrollDict();
                    event.put("status", AnimationViewProxy.ANIMATION_START);
                    event.put("frame", 0);
                    ((AnimationViewProxy) proxy).updateEvent(event);
                }

                @Override
                public void onAnimationCancel(Animator animation) {
                    KrollDict event = new KrollDict();
                    event.put("status", AnimationViewProxy.ANIMATION_CANCEL);
                    ((AnimationViewProxy) proxy).updateEvent(event);
                }

                @Override
                public void onAnimationRepeat(Animator animation) {
                    KrollDict event = new KrollDict();
                    event.put("status", AnimationViewProxy.ANIMATION_END);
                    event.put("repeat", true);
                    event.put("loop", TiConvert.toBoolean(proxy.getProperty("loop")));
                    ((AnimationViewProxy) proxy).completeEvent(event);
                }

                @Override
                public void onAnimationEnd(Animator animation) {
                    KrollDict event = new KrollDict();
                    event.put("status", AnimationViewProxy.ANIMATION_END);
                    event.put("repeat", false);
                    event.put("loop", TiConvert.toBoolean(proxy.getProperty("loop")));
                    ((AnimationViewProxy) proxy).completeEvent(event);
                }
            });
            va.start();
        }
    }

    void pauseAnimation() {
        proxy.setProperty("paused", true);

        if (animationType == ANIMATION_RIVE) {
            riveView.pause();
        } else {
            if (va != null) {
                va.pause();
            } else {
                lottieView.pauseAnimation();
            }
        }
    }

    void resumeAnimation() {
        proxy.setProperty("paused", false);
        if (animationType == ANIMATION_RIVE) {
            riveView.play(Loop.AUTO, Direction.AUTO, true);
        } else {
            if (va != null) {
                va.resume();
            } else {
                lottieView.resumeAnimation();
            }
        }
    }

    void stopAnimations() {
        proxy.setProperty("paused", false);

        if (animationType == ANIMATION_RIVE) {
            riveView.stop();
        } else {
            if (va != null) {
                va.cancel();
            } else {
                lottieView.cancelAnimation();
            }
        }
    }

    void setText(String layer, String text) {
        delegate.setText(layer, text);
    }

    float getProgress() {
        if (animationType == ANIMATION_RIVE) return 0;
        return lottieView.getProgress();
    }

    void setProgress(float val) {
        if (animationType == ANIMATION_RIVE) return;
        lottieView.setProgress(val);
    }

    int getFrame() {
        if (animationType == ANIMATION_RIVE) return 0;
        return lottieView.getFrame();
    }

    void setFrame(int val) {
        if (animationType == ANIMATION_RIVE) return;
        lottieView.setFrame(val);
    }

    public void setAnimationName(Object animationName) {
        if (animationType == ANIMATION_RIVE) {
            if (animationName instanceof String) {
                riveView.play((String) animationName, Loop.ONESHOT, Direction.AUTO, false, true);
            } else if (animationName instanceof Object[]) {
                Object[] objVal = (Object[]) animationName;
                List<String> lst = new ArrayList<String>();
                for (Object s : objVal) {
                    lst.add((String) s);
                }
                riveView.play(lst, Loop.ONESHOT, Direction.AUTO, false, true);
            }
        }
    }

    public void resetAnimation() {
        if (animationType == ANIMATION_RIVE) {
            try {
                riveView.stop();
                riveView.clearAnimation();
                riveView.reset();
                riveView.stop();
            } catch (Exception e) {
                Log.e(LCAT, e.getMessage());
            }
        }
    }

    protected class AnimatorUpdateListener implements ValueAnimator.AnimatorUpdateListener {
        public void onAnimationUpdate(ValueAnimator animation) {
            KrollDict event = new KrollDict();
            event.put("frame", lottieView.getFrame());
            event.put("status", AnimationViewProxy.ANIMATION_RUNNING);
            ((AnimationViewProxy) proxy).updateEvent(event);
        }
    }

    protected class AnimatorListener implements Animator.AnimatorListener {
        public void onAnimationStart(Animator animation) {
            KrollDict event = new KrollDict();
            event.put("status", AnimationViewProxy.ANIMATION_START);
            event.put("frame", 0);
            ((AnimationViewProxy) proxy).updateEvent(event);
        }

        public void onAnimationEnd(Animator animation) {
            KrollDict event = new KrollDict();
            event.put("status", AnimationViewProxy.ANIMATION_END);
            event.put("loop", TiConvert.toBoolean(proxy.getProperty("loop")));
            event.put("repeat", false);
            ((AnimationViewProxy) proxy).completeEvent(event);
        }

        public void onAnimationCancel(Animator animation) {
            KrollDict event = new KrollDict();
            event.put("status", AnimationViewProxy.ANIMATION_CANCEL);
            ((AnimationViewProxy) proxy).updateEvent(event);
        }

        public void onAnimationRepeat(Animator animation) {
            KrollDict event = new KrollDict();
            event.put("status", AnimationViewProxy.ANIMATION_END);
            event.put("loop", TiConvert.toBoolean(proxy.getProperty("loop")));
            event.put("repeat", true);
            ((AnimationViewProxy) proxy).completeEvent(event);
        }
    }

}
